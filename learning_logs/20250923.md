SpringBoot간단설명
Entity의 개념
JPA가 그래서 Entity와 어떻게 연결되어있고, inmemory databafse인 h2와 어떻게 연결이 되는지 여부도 수업
build.gradle / application.properties라고 하는 파일들에 명령어들을 작성하게 됐습니다.

Entity 클래스의 경우에는 DB에서의 table역할을함.
Entity 클래스의 field들은

```java
package com.example.cardatabase.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    private final String firstName;
    private final String lastName;
    
}
```
`@NoArgsConstructor(force = true)` : final 필드가 있는 경우메도 해당 필드를 null로 초기화하는 생성자를 강제로 생성해주기 때문에 `final`  키워드가 붙은 경우에도 JPA에서 요구되는 기본 생성자를 만들 수 있고, `@NoArgsConstructor`와도 충돌하지 않습니다.

이상의 일대다 관곌를 주가하려면 `@ManyToOne`과`@OneToMany` 애너테이션(jakarta.persistence)을 이용해야 합니다. 외래 키를 포함한 Car엔티티 클래스에서는 `@ManyToOne`을 사용할겁니다.(이것 때문에 위애 부분 복사핼왔습니다). 그리고 왜래키를 추가 했기 대문에 field 구성이 달라져야겠죠.

그럼 DB적으로 봤을 때는 car table에다가 왜래키인 wonerId를 추가하는 개념이라고 볼수 있기 때문에 Car entity class에는 Owner 관련 field를 추가해야 합니다. 그렇다면

FetchType : DB에서 데이터를 검생하는 전략을 정의. 속성값으로는
  EAGER : 즉시검색
  LAZY : 지연 검색
저의 예제에서는 지연 검색(LAZY)은 DB에서 소유자를 검색하면 필요할 때 해당 소유자와 연관된 모든 자동차를 검색한다는 의미이빈다. 반변 즉시 검색(EAGER)은 해당 소유자의 모든 자동차를 즉시 검색합니다.

```java
// car.java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;

@NoArgsConstructor
@Data
@Entity

public class Car {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String brand, model, color, registrationNumber;
    private int modelYear, price;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "owner")
    private Owner owner;

    public Owner getOwner() {
        return owner;
    }

    public void setOwner(Owner owner) {
        this.owner = owner;
    }

    public Car(String brand, String model, String color, String registrationNumber, int modelYear, int price) {
        this.brand = brand;
        this.model = model;
        this.color = color;
        this.registrationNumber = registrationNumber;
        this.modelYear = modelYear;
        this.price = price;
    }


}

// owner.java
package com.example.cardatabase.domain;

import jakarta.persistence.*;
import lombok.*;

import java.util.List;

@Entity
@Getter
@Setter
@ToString
@NoArgsConstructor(force = true)
@RequiredArgsConstructor
public class Owner {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long ownerId;

    @NonNull
    private String firstName;
    @NonNull
    private String lastName;

    // 소유자는 다수의 차들을 가질 수 있기 때문에 Collections를 사용
    @OneToMany(cascade = CascadeType.ALL, mappedBy = "owner")
    private List<Car> cars;
}

```
이상의 코드에서 `@Data`를 달아둔 경우에 일부러 겹치지만 Owner와 관련된 getter / setter를 코드로 써두었습니다. 반면에 `@Getter, @Setter`를 명시해둔 Owner 클래스에는 cars관련 getter / setter를 안썻습니다. 당연히 프로젝트를 하실 때는 setOwner() / getOwner()를 코드로 쓰실 필요가 없습니다.

Owner class의 `@OneToMany` 애너테이션에는 특성이 있습니다.
1. cascade 속성은 삭제 / 업데이트시 연속 효과가 적용되는 방법을 지정합니다.
  - All로 설정하게 되면 모든 작업이 연속적으로 정용됩니다.
  - 예를 들어 Owner를 삭제하게 되면 그 소유자와 연결된 Car 객체들도 전부 다 삭제됩니다.
2. mappedBy="owner" 속성 설정 : Car 클래스 사이에 이 관계의 외래 키인 owner 필드가 존재함을 명시함.

SQL을 배운 저희가 좀 어색하게 느껴질 수 있는 것은 OwnerId 피드 하나만 가지고 와서 연결짓는게 아니라 Owner 클래스를 통째로 들고와서 Car에 field로 삼는다는 점입니다.